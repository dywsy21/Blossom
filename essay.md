---
title: "对于一般图的最大匹配算法实现"
author: "王思宇"
date: \today
using_title: true
using_table_of_content: true
---

\section*{摘要}
    图的最大匹配问题是图论中的一个经典问题，它的应用非常广泛。本文将基于论文*Paths, Trees, and Flowers*[1]使用C/C++实现一种求解一般图的最大匹配的，复杂度为 $O(|V|^2 * |E|)$ 的带花树算法。

**关键字:** 图论, 最大匹配, 矩阵消元

# 对于一般图的最大匹配算法实现

## 问题描述与定义

给定一个图 $G = (V, E)$，求出一个最大的边集$M$，使得$M$是$G$的一个匹配。

## 重要理论基础

### 交错路径与增广路径

1. 交错路径：一条交错路径是一个匹配边和非匹配边上交替出现的路径。
2. 增广路径：一条交错路径，且路径的起点和终点都是未匹配的顶点。

显然，如果存在一条增广路径，那么可以通过将路径上的匹配边和非匹配边交换，从而增加匹配的边数。

我们的思路就是不断遍历所有非匹配点，从而在图中寻找到所有的增广路径，这样就能找到图的最大匹配。

### 问题与解决方案

增广路径的方法有且仅有一个问题：碰到奇环时，不能简单地将路径上的匹配边和非匹配边交换，因为这样会破坏匹配的性质。

这就是带花树算法的核心思想：将图中的所有奇环（"花"）缩成一个点，从而将问题转化为一个二分图的最大匹配问题。

## 核心思路

1. **搜索增广路径**
- 从一个未匹配点出发，使用 BFS/DFS 搜索增广路径。
- 搜索过程中，将点分为两类（层级分割），交替加入“匹配边”和“非匹配边”。
- 如果找到另一未匹配点，则可以形成一条增广路径。

2. **处理奇环（缩环操作）**
- 当在搜索中发现一个奇数环（即 BFS/DFS 遇到一个已经访问过的点，并且两个路径的深度相同），则将其缩成一个点，在缩环后的图中继续搜索增广路径。

- 如果在缩环后的图中找到了增广路径，将该路径还原到原图中。

3. **匹配扩展**
找到增广路径后，通过反转路径中的匹配和非匹配边，扩大匹配。
如果没有找到增广路径，算法终止，当前匹配即为最大匹配。

## 实现思路

### 数据结构


## 参考文献

[1] Edmonds J. Paths, Trees, and Flowers. Canadian Journal of Mathematics. 1965;17:449-467. doi:10.4153/CJM-1965-045-4
